#!/usr/bin/env bash

# initialize global variables
rows=0
cols=0
  

# Based on the command specified by the first argument, call the appropriate function
function what_to_do()
{
  case $1 in 
  dims)
    stdin_or_file "$@"
    ;;
  transpose)
    stdin_or_file "$@"
    ;;
  mean)
    stdin_or_file "$@"
    ;;
  add)
    add "$2" "$3"
    ;;
  multiply)
    multiply "$2" "$3"
    ;;
  *)
    problems "no valid command specified."
    ;;
  esac
}

# Checks if file exists "-e" and is readable "-r"
function is_file_readable()
{
  if [[ ! -e "$1" ]] || [[ ! -r "$1" ]] # remove this test to trigger grading bug
  then
    problems "file $1 unreadable or does not exist"
    exit
  fi
}

# For the single-matrix commands, this function reads from a file,
# or if no file is specified, reads from stdin.
function stdin_or_file()
{
  # Check for the right number of arguments
  if [[ "${#@}" -gt 2 ]]
  then
    problems "the $1 command must be called with 0 or 1 arguments"
    exit
  fi

  # $2 is the filename argument. If it's null (-z), then read from stdin instead
  if [[ -z "$2" ]]
  then
    # stdin
    cat - | "$1"
  else
    # file
    is_file_readable $2
    cat "$2" | "$1"
  fi
}

# Reads a matrix from stdin and coverts it to a 1D array of
# integers.
function matrix_into_memory()
{
  local line data temp rows cols

  while read line
  do
    temp=($line)
    data=(${data[@]} ${temp[@]})
    ((rows++))

    # If the columns variable hasn't yet been set,
    # set it.
    if [[ $cols -eq 0 ]]
    then
      cols=${#temp[@]}
    fi
  done

  # the matrix dimensions are stored in the first
  # two elements of this array, followed by all of
  # the elements of the matrix
  data=($rows $cols ${data[@]})

  # print the array to stdout
  echo ${data[@]}
}

function dims()
{
  local temp

  temp=($(cat - | matrix_into_memory))
  # Assign names to the rows and column values from the array
  # returned by matrix_into_memory
  rows=${temp[@]:0:1}
  cols=${temp[@]:1:1}

  echo "$rows $cols"
}

function transpose()
{
  local temp j i

  temp=($(cat - | matrix_into_memory))
  rows=${temp[@]:0:1}
  cols=${temp[@]:1:1}
  # Trim the first two elements from the beginning of $temp,
  # removing the row and column numbers
  temp=(${temp[@]:2:$((${#temp[@]} - 2))})
  
  for i in $(eval echo {0..$((cols - 1))})
  do
    j=$i

    while [[ $j -lt $((rows * cols)) ]]
    do
      echo -ne "${temp[$j]}"

      # only print tabs if we're not on the last column
      if ! [[ $j -eq $((i + (rows-1)*cols)) ]]
      then
        echo -ne "\t"
      fi

      ((j = j + cols))
    done

    echo
  done
}

function mean()
{
  local temp avg

  temp=($(cat - | matrix_into_memory))
  rows=${temp[@]:0:1}
  cols=${temp[@]:1:1}
  temp=(${temp[@]:2:$((${#temp[@]} - 2))})

  for i in $(eval echo {0..$((cols - 1))})
  do
    j=$i
    avg=0

    while [[ $j -lt $((rows * cols)) ]]
    do
      ((avg += "${temp[$j]}"))
      ((j = j + cols))
    done
    
    # Integer rounding formula from assignment description
    (( avg = (avg + (rows/2)*( (avg>0)*2-1 )) / rows))
    echo -n "$avg"

    # only print tabs if we're not on the last column
    if ! [[ $i -eq $((cols - 1)) ]]
    then
      echo -ne "\t"
    fi
  done

  echo
}

function add()
{
  is_file_readable "$1"
  is_file_readable "$2"
  mat_l=($(cat "$1" | matrix_into_memory))
  mat_r=($(cat "$2" | matrix_into_memory))
  rows=(${mat_l[@]:0:1} ${mat_r[@]:0:1})
  cols=(${mat_l[@]:1:1} ${mat_r[@]:1:1})
  mat_l=(${mat_l[@]:2:$((${#mat_l[@]} - 2))})
  mat_r=(${mat_r[@]:2:$((${#mat_r[@]} - 2))})

  if [[ ! $rows -eq ${rows[1]} ]] || [[ ! $cols -eq ${cols[1]} ]]
  then
    problems "matrix dimensions must match for addition"
    exit
  fi

  # Index the 1D arrays $mat_l and $mat_r as 2D arrays
  # For every row
  for i in $(eval echo {0..$((rows - 1))})
  do
    # For every column in that row
    for j in $(eval echo {$((i*cols))..$(((i + 1)*cols - 1))})
    do
      # Add the two elements at $i,$j
      echo -n $((${mat_l[j]} + ${mat_r[j]}))

      if ! [[ $j -eq $(((i + 1)*cols - 1)) ]]
      then
        echo -ne "\t"
      fi
    done

    echo
  done
}

function multiply()
{
  is_file_readable "$1"
  is_file_readable "$2"
  mat_l=($(cat "$1" | matrix_into_memory))
  mat_r=($(cat "$2" | matrix_into_memory))
  # Store the dimensions of each matrix in the following arrays
  rows=(${mat_l[@]:0:1} ${mat_r[@]:0:1})
  cols=(${mat_l[@]:1:1} ${mat_r[@]:1:1})
  mat_l=(${mat_l[@]:2:$((${#mat_l[@]} - 2))})
  mat_r=(${mat_r[@]:2:$((${#mat_r[@]} - 2))})

  if [[ $cols -ne ${rows[1]} ]]
  then
    problems "matrix dimensions must be of the form MxN, NxP for multiplication"
    exit
  fi

  # For every row in the left matrix
  for i in $(eval echo {0..$((rows - 1))})
  do
    # For every column in the right matrix
    for j in $(eval echo {0..$((${cols[1]} - 1))})
    do
      sum=0

      # For every row in the right matrix
      for k in $(eval echo {0..$((${rows[1]} - 1))})
      do
        # Accumulate $sum as the dot product of the row vectors of the left matrix
        # and the column vectors of the right matrix
        ((sum += ${mat_l[$((i*cols + k))]} * ${mat_r[$((j + k*${cols[1]}))]}))
      done

      echo -n "$sum"

      if ! [[ $j -eq $((${cols[1]} - 1)) ]]
      then
        echo -ne "\t"
      fi
    done

    echo
  done
}

# prints an error message and returns 1
function problems()
{
  echo "$0: error: $1" 1>&2
  return 1
}


# Execution starts here
# Pass all arguments to 
what_to_do "$@"
